<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Leetcode——剑指 Offer</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="数组/数组.html"><strong aria-hidden="true">1.</strong> 数组</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="数组/二分查找.html"><strong aria-hidden="true">1.1.</strong> 二分查找</a></li><li class="chapter-item expanded "><a href="数组/旋转数组.html"><strong aria-hidden="true">1.2.</strong> 旋转数组</a></li><li class="chapter-item expanded "><a href="数组/矩阵.html"><strong aria-hidden="true">1.3.</strong> 矩阵</a></li></ol></li><li class="chapter-item expanded "><a href="链表/链表.html"><strong aria-hidden="true">2.</strong> 链表</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="链表/反转链表.html"><strong aria-hidden="true">2.1.</strong> 反转链表</a></li></ol></li><li class="chapter-item expanded "><a href="哈希表.html"><strong aria-hidden="true">3.</strong> 哈希表</a></li><li class="chapter-item expanded "><a href="字符串.html"><strong aria-hidden="true">4.</strong> 字符串</a></li><li class="chapter-item expanded "><a href="双指针/双指针.html"><strong aria-hidden="true">5.</strong> 双指针</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="双指针/移动元素.html"><strong aria-hidden="true">5.1.</strong> 移动元素</a></li><li class="chapter-item expanded "><a href="双指针/三数之和.html"><strong aria-hidden="true">5.2.</strong> 三数之和</a></li><li class="chapter-item expanded "><a href="双指针/接雨水.html"><strong aria-hidden="true">5.3.</strong> 接雨水</a></li></ol></li><li class="chapter-item expanded "><a href="栈与队列.html"><strong aria-hidden="true">6.</strong> 栈与队列</a></li><li class="chapter-item expanded "><a href="二叉树/二叉树.html"><strong aria-hidden="true">7.</strong> 二叉树</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="二叉树/二叉树遍历.html"><strong aria-hidden="true">7.1.</strong> 二叉树遍历</a></li><li class="chapter-item expanded "><a href="二叉树/路径之和.html"><strong aria-hidden="true">7.2.</strong> 路径之和</a></li><li class="chapter-item expanded "><a href="二叉树/二叉树半径.html"><strong aria-hidden="true">7.3.</strong> 二叉树半径</a></li><li class="chapter-item expanded "><a href="二叉树/二叉树右视图.html"><strong aria-hidden="true">7.4.</strong> 二叉树右视图</a></li></ol></li><li class="chapter-item expanded "><a href="回溯.html"><strong aria-hidden="true">8.</strong> 回溯</a></li><li class="chapter-item expanded "><a href="贪心.html"><strong aria-hidden="true">9.</strong> 贪心</a></li><li class="chapter-item expanded "><a href="动态规划.html"><strong aria-hidden="true">10.</strong> 动态规划</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Leetcode——剑指 Offer</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<ul>
<li><a href="%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">数组理论基础</a></li>
</ul>
<h1 id="数组理论基础"><a class="header" href="#数组理论基础">数组理论基础</a></h1>
<p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p>
<p>数组可以方便的通过下标索引的方式获取到下标对应的数据。</p>
<p>需要两点注意的是</p>
<ul>
<li><strong>数组下标都是从0开始的。</strong></li>
<li><strong>数组内存空间的地址是连续的</strong></li>
</ul>
<p>正是<strong>因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></p>
<p><strong>数组的元素是不能删的，只能覆盖。</strong></p>
<p><strong>那么二维数组在内存的空间地址是连续的么？</strong></p>
<p>不同编程语言的内存管理是不一样的，以C++为例，在C++中二维数组是连续分布的。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="二分查找"><a class="header" href="#二分查找">二分查找</a></h1>
<ul>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%9D%A5%E6%BA%90%E8%AF%B4%E6%98%8E">来源说明</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#704-binary-search">704. Binary Search</a>
<ul>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF">思路</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#c-%E5%86%99%E6%B3%95">C++ 写法</a>
<ul>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95">二分查找第一种写法</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%86%99%E6%B3%95">二分查找第二种写法</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#35-search-insert-position">35. Search Insert Position</a>
<ul>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF-1">思路</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#c-%E8%A7%A3%E6%B3%95">C++ 解法</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#java-%E8%A7%A3%E6%B3%95">Java 解法</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#python-%E8%A7%A3%E6%B3%95">Python 解法</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#34-find-first-and-last-position-of-element-in-sorted-array">34. Find First and Last Position of Element in Sorted Array</a>
<ul>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF-2">思路</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#c-%E8%A7%A3%E6%B3%951">C++ 解法1</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#c-%E8%A7%A3%E6%B3%952">C++ 解法2</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#java-%E8%A7%A3%E6%B3%95-1">Java 解法</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#python-%E8%A7%A3%E6%B3%95-1">Python 解法</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#162-find-peak-element">162. Find Peak Element</a>
<ul>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF-3">思路</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#c-%E8%A7%A3%E6%B3%95-1">C++ 解法</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#java-%E8%A7%A3%E6%B3%95-2">Java 解法</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#python-%E8%A7%A3%E6%B3%95-2">Python 解法</a></li>
</ul>
</li>
</ul>
<h2 id="来源说明"><a class="header" href="#来源说明">来源说明</a></h2>
<p><a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html">二分查找来源于编程随想录</a></p>
<h1 id="704-binary-search"><a class="header" href="#704-binary-search"><a href="https://leetcode.com/problems/binary-search/">704. Binary Search</a></a></h1>
<p>Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.</p>
<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> nums = [-1,0,3,5,9,12], target = 9
<strong>Output:</strong> 4
<strong>Explanation:</strong> 9 exists in nums and its index is 4</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> nums = [-1,0,3,5,9,12], target = 2
<strong>Output:</strong> -1
<strong>Explanation:</strong> 2 does not exist in nums so return -1</p>
</blockquote>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^4</code></li>
<li><code>-10^4 &lt; nums[i], target &lt; 10^4</code></li>
<li>All the integers in <code>nums</code> are <strong>unique</strong>.</li>
<li><code>nums</code> is sorted in ascending order.</li>
</ul>
<h2 id="思路"><a class="header" href="#思路">思路</a></h2>
<p><strong>这道题目的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p>
<p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p>
<p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p>
<p>写二分法，区间的定义一般为两种，左闭右闭即<code>[left, right]</code>，或者左闭右开即<code>[left, right)</code>。</p>
<p>下面我用这两种区间的定义分别讲解两种不同的二分查找写法。</p>
<h2 id="c-写法"><a class="header" href="#c-写法">C++ 写法</a></h2>
<h3 id="二分查找第一种写法"><a class="header" href="#二分查找第一种写法">二分查找第一种写法</a></h3>
<p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是<code>[left, right]</code> （这个很重要非常重要）</strong>。</p>
<p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在<code>[left, right]</code>区间，所以有如下两点：</strong></p>
<ul>
<li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li>
<li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>
</ul>
<p>代码如下：</p>
<pre><code class="language-cpp">// 版本一
class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left &lt;= right) { // 当left==right，区间[left, right]依然有效，所以用 &lt;=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] &gt; target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] &lt; target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
</code></pre>
<ul>
<li>时间复杂度：O(log n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="二分查找第二种写法"><a class="header" href="#二分查找第二种写法">二分查找第二种写法</a></h3>
<p>如果说定义 target 是在一个在左闭右开的区间里，也就是<code>[left, right)</code> ，那么二分法的边界处理方式则截然不同。</p>
<p>有如下两点：</p>
<ul>
<li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间<code>[left, right)</code>是没有意义的</li>
<li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li>
</ul>
<p>代码如下：（详细注释）</p>
<pre><code class="language-cpp">// 版本二
class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        int left = 0;
        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)
        while (left &lt; right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;
            int middle = left + ((right - left) &gt;&gt; 1);
            if (nums[middle] &gt; target) {
                right = middle; // target 在左区间，在[left, middle)中
            } else if (nums[middle] &lt; target) {
                left = middle + 1; // target 在右区间，在[middle + 1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
</code></pre>
<ul>
<li>时间复杂度：O(log n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>二分法是非常重要的基础算法，为什么很多同学对于二分法都是<strong>一看就会，一写就废</strong>？</p>
<p>其实主要就是对区间的定义没有理解清楚，在循环中没有始终坚持根据查找区间的定义来做边界处理。</p>
<p>区间的定义就是不变量，那么在循环中坚持根据查找区间的定义来做边界处理，就是循环不变量规则。</p>
<p>本篇根据两种常见的区间定义，给出了两种二分法的写法，每一个边界为什么这么处理，都根据区间的定义做了详细介绍。</p>
<p>相信看完本篇应该对二分法有更深刻的理解了。</p>
<h1 id="35-search-insert-position"><a class="header" href="#35-search-insert-position"><a href="https://leetcode.com/problems/search-insert-position/">35. Search Insert Position</a></a></h1>
<p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> nums = [1,3,5,6], target = 5<br />
<strong>Output:</strong> 2</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> nums = [1,3,5,6], target = 2<br />
<strong>Output:</strong> 1</p>
<p><strong>Example 3:</strong></p>
<p><strong>Input:</strong> nums = [1,3,5,6], target = 7<br />
<strong>Output:</strong> 4</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^4</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
<li><code>nums</code> contains <strong>distinct</strong> values sorted in <strong>ascending</strong> order.</li>
<li><code>-10^4 &lt;= target &lt;= 10^4</code></li>
</ul>
<h2 id="思路-1"><a class="header" href="#思路-1">思路</a></h2>
<p>先看在不在数组里，在的话输出下标；不在的话看是不是比前一个大，比后一个小，注意数组越界的问题。</p>
<p>要是上来就比第一个数小就输出零，比最后一个大输出数组长度。</p>
<p>不管 target 是在一个左闭右闭的区间里还在在一个左闭右开的区间里，在数组中找不到 target 时，都需要<code>return left</code>。</p>
<h2 id="c-解法"><a class="header" href="#c-解法">C++ 解法</a></h2>
<p>假设target 是在一个在左闭右闭的区间里，也就是<code>[left, right]</code></p>
<pre><code class="language-cpp">class Solution {
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while(left &lt;= right){
            int mid = (right + left) / 2;
            if(nums[mid] &lt; target){
                left = mid + 1;
            }else if(nums[mid] &gt; target){
                right = mid - 1;
            }else{
                return mid;
            }
        }
        return left;

    }
};
</code></pre>
<h2 id="java-解法"><a class="header" href="#java-解法">Java 解法</a></h2>
<p>假设target 是在一个在左闭右闭的区间里，也就是<code>[left, right]</code></p>
<pre><code class="language-java">class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left &lt;= right){
            int mid = left + (right - left) / 2;
            if(nums[mid] &lt; target){
                left = mid + 1;
            }else if(nums[mid] &gt; target){
                right = mid - 1;
            }else{
                return mid;
            }
        }
        return left;
    }
}
</code></pre>
<h2 id="python-解法"><a class="header" href="#python-解法">Python 解法</a></h2>
<p>假设target 是在一个在左闭右闭的区间里，也就是<code>[left, right]</code></p>
<pre><code class="language-python">class Solution:
    def searchInsert(self, nums: List[int], target: int) -&gt; int:
        left = 0
        right = len(nums) - 1

        while left &lt;= right:
            mid = (left + right) // 2

            if nums[mid] == target:
                return mid
            elif nums[mid] &gt; target:
                right = mid - 1
            else:
                left = mid + 1
        
        return left
</code></pre>
<h1 id="34-find-first-and-last-position-of-element-in-sorted-array"><a class="header" href="#34-find-first-and-last-position-of-element-in-sorted-array"><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. Find First and Last Position of Element in Sorted Array</a></a></h1>
<p>Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.</p>
<p>If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p>
<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 8<br />
<strong>Output:</strong> [3,4]</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 6<br />
<strong>Output:</strong> [-1,-1]</p>
<p><strong>Example 3:</strong></p>
<p><strong>Input:</strong> nums = [], target = 0<br />
<strong>Output:</strong> [-1,-1]</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>nums</code> is a non-decreasing array.</li>
<li><code>-10^9 &lt;= target &lt;= 10^9</code></li>
</ul>
<h2 id="思路-2"><a class="header" href="#思路-2">思路</a></h2>
<p>寻找target在数组里的左右边界，有如下三种情况：</p>
<ul>
<li>情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}</li>
<li>情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}</li>
<li>情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}</li>
</ul>
<p>这三种情况都考虑到，说明就想的很清楚了。</p>
<p>接下来，在去寻找左边界，和右边界了。</p>
<p>方法1：一次二分查找，再扩展区间</p>
<p>方法2：使用两次二分查找，分别查找<code>lower_bound</code>和<code>upper_bound</code>。</p>
<p><strong>刚刚接触二分搜索的同学不建议上来就想用一个二分来查找左右边界，很容易把自己绕进去，建议扎扎实实的写两个二分分别找左边界和右边界</strong></p>
<p>确定好：计算出来的右边界是不包含target的右边界，左边界同理。</p>
<h2 id="c-解法1"><a class="header" href="#c-解法1">C++ 解法1</a></h2>
<p>假设target 是在一个在左闭右闭的区间里，也就是<code>[left, right]</code></p>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {
        int leftBorder = getLeftBorder(nums, target);
        int rightBorder = getRightBorder(nums, target);
        // 情况一
        if (leftBorder == -2 || rightBorder == -2) return {-1, -1};
        // 情况三
        if (rightBorder - leftBorder &gt; 1) return {leftBorder + 1, rightBorder - 1};
        // 情况二
        return {-1, -1};
    }
private:
     int getRightBorder(vector&lt;int&gt;&amp; nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int rightBorder = -2; // 记录一下rightBorder没有被赋值的情况
        while (left &lt;= right) {
            int middle = left + ((right - left) / 2);
            if (nums[middle] &gt; target) {
                right = middle - 1;
            } else { // 寻找右边界，nums[middle] == target的时候更新left
                left = middle + 1;
                rightBorder = left;
            }
        }
        return rightBorder;
    }
    int getLeftBorder(vector&lt;int&gt;&amp; nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况
        while (left &lt;= right) {
            int middle = left + ((right - left) / 2);
            if (nums[middle] &gt;= target) { // 寻找左边界，nums[middle] == target的时候更新right
                right = middle - 1;
                leftBorder = right;
            } else {
                left = middle + 1;
            }
        }
        return leftBorder;
    }
};
</code></pre>
<h2 id="c-解法2"><a class="header" href="#c-解法2">C++ 解法2</a></h2>
<p>lower_bound倾向于找左边的元素，所以只有<code>nums[mid] &lt; target</code>时才移动左指针；而upper_bound倾向于找右边的元素，所以当<code>nums[mid] &lt;= target</code>就向右移动左指针了。</p>
<p>lower_bound返回的是开始的第一个满足条件的位置，而upper_bound返回的是第一个不满足条件的位置。所以，当两个相等的时候代表没有找到，如果找到了的话，需要返回的是<code>[left, right - 1]</code>。</p>
<pre><code class="language-cpp">class Solution {
public:
    int lower_bound(vector&lt;int&gt;&amp; nums, int target) {
        int left = 0;
        int right = nums.size();
        while(left &lt; right){
            int mid = (right + left) / 2;
            if(nums[mid] &lt; target){
                left = mid + 1;
            }else{
                right = mid;
            }
        }
        return left;

    }

    int upper_bound(vector&lt;int&gt;&amp; nums, int target){
        int left = 0;
        int right = nums.size();
        while(left &lt; right){
            int mid = (right + left) / 2;
            if(nums[mid] &lt;= target){
                left = mid + 1;
            }else {
                right = mid;
            }
        }
        return left;

    }
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {
        int leftBorder = lower_bound(nums, target);
        int rightBorder = upper_bound(nums, target);

        if (leftBorder == rightBorder) 
            return {-1, -1};
        else
            return {leftBorder, rightBorder - 1};
    }
};
</code></pre>
<h2 id="java-解法-1"><a class="header" href="#java-解法-1">Java 解法</a></h2>
<p>假设target 是在一个在左闭右开的区间里，也就是<code>[left, right)</code></p>
<p>先尝试找到一个target，找不到则返回<code>{-1, -1}</code>，找到时则向两边扩展得结果</p>
<pre><code class="language-java">class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] result = {-1, -1};
        int left = 0;
        int right = nums.length;
        boolean isExist = false;
        while(left &lt; right){
            int mid = left + (right - left) / 2;
            if(nums[mid] &lt; target){
                left = mid + 1;
            }else if(nums[mid] &gt; target){
                right = mid;
            }else{
                isExist = true;
                break;
            }
        }
        if(isExist){
            int mid = left + (right - left) / 2;
            int i = mid;
            int j = mid;
            while(i &gt;= 0 &amp;&amp; nums[i] == target){
                i--;
            }
            while(j &lt; nums.length &amp;&amp; nums[j] == target){
                j++;
            }
            result[0] = i + 1;
            result[1] = j - 1;
        }
         return result;
    }
}
</code></pre>
<h2 id="python-解法-1"><a class="header" href="#python-解法-1">Python 解法</a></h2>
<p>假设target 是在一个在左闭右开的区间里，也就是<code>[left, right)</code></p>
<pre><code class="language-python">class Solution(object):
    def searchRange(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        left = bisect.bisect_left(nums, target)
        right = bisect.bisect_right(nums, target)
        if left == right:
            return [-1, -1]
        return [left, right - 1]
</code></pre>
<h1 id="162-find-peak-element"><a class="header" href="#162-find-peak-element"><a href="https://leetcode.com/problems/find-peak-element/">162. Find Peak Element</a></a></h1>
<p>A peak element is an element that is strictly greater than its neighbors.</p>
<p>Given a <strong>0-indexed</strong> integer array <code>nums</code>, find a peak element, and return its index. If the array contains multiple peaks, return the index to <strong>any of the peaks</strong>.</p>
<p>You may imagine that <code>nums[-1] = nums[n] = -∞</code>. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.</p>
<p>You must write an algorithm that runs in <code>O(log n)</code> time.</p>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> nums = [1,2,3,1]<br />
<strong>Output:</strong> 2<br />
<strong>Explanation:</strong> 3 is a peak element and your function should return the index number 2.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> nums = [1,2,1,3,5,6,4]<br />
<strong>Output:</strong> 5<br />
<strong>Explanation:</strong> Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li>
<li><code>nums[i] != nums[i + 1]</code> for all valid <code>i</code>.</li>
</ul>
<h2 id="思路-3"><a class="header" href="#思路-3">思路</a></h2>
<p>给一个数组，找出其中的峰顶数据，就是大于两个邻居的数的index，如果有多个答案，任意一个都可以。</p>
<p>这个题可以直接使用最简单的暴力搜索，遍历整个数组，时间复杂度为O(n).虽然题目要求是log时间，但是这样也可以AC。</p>
<p>但是也可以实现O(logn)的时间复杂度。可以用binary search。每次寻找中间的数，如果恰好是峰顶数据，就返回index。如果不是，就查看其与中间元素相邻的左边和右边的值，选取大于中间元素的那边的一半数组继续遍历，如果两边都大于，就随便选一个。注意，这里是没有考虑相同的数据挨着的情况的。</p>
<h2 id="c-解法-1"><a class="header" href="#c-解法-1">C++ 解法</a></h2>
<pre><code class="language-cpp">class Solution {
public:
    int findPeakElement(vector&lt;int&gt;&amp; nums) {
        int size = nums.size();
        if(size &lt;= 1 || nums[0] &gt; nums[1])
            return 0;
        if(nums[size - 2] &lt; nums[size - 1]){
            return size - 1;
        }
        for(int i = 1; i &lt; nums.size() - 1; i++){
            if(nums[i] &gt; nums[i - 1] &amp;&amp; nums[i] &gt; nums[i + 1]){
                return i;
            }
        }
        return -1;
    }
};
</code></pre>
<h2 id="java-解法-2"><a class="header" href="#java-解法-2">Java 解法</a></h2>
<p>分治策略</p>
<p>二分查找区间类型为左闭右闭</p>
<pre><code class="language-java">class Solution {
    public int findPeakElement(int[] nums) {
        return binarySearchToFindPeakElement(nums, 0, nums.length - 1);
    }
    public int binarySearchToFindPeakElement(int[] nums, int left, int right){
        if(left &gt; right)
            return -1;
        if(left == right)
            return left;
        if(left + 1 == right) 
            return nums[left] &gt; nums[right] ? left : right;
        int mid = left + (right - left) / 2;
        if(nums[mid] &lt; nums[mid + 1]){
            return binarySearchToFindPeakElement(nums, mid + 1, right);
        }else if(nums[mid] &lt; nums[mid - 1] ){
            return binarySearchToFindPeakElement(nums, left, mid -1);
        }else{
            return mid;
        }
    }
}
</code></pre>
<h2 id="python-解法-2"><a class="header" href="#python-解法-2">Python 解法</a></h2>
<p>二分查找区间类型为左闭右闭</p>
<pre><code class="language-python">class Solution:
    def findPeakElement(self, nums: List[int]) -&gt; int:
        left, right = 0, len(nums) - 1
        while left &lt; right:
            mid = (left + right)  &gt;&gt; 1
            if nums[mid - 1] &lt;= nums[mid] &gt;= nums[mid + 1]:
                return mid
            elif nums[mid] &lt; nums[mid + 1]:
                left = mid + 1
            else:
                right = mid
        return left
        
</code></pre>
<p>更精简的写法如下：</p>
<pre><code class="language-python">class Solution:
    def findPeakElement(self, nums: List[int]) -&gt; int:
        left, right = 0, len(nums) - 1
        while left &lt; right:
            mid = (left + right) &gt;&gt; 1
            if nums[mid] &lt; nums[mid + 1]:
                left = mid + 1
            else:
                right = mid
        return right
</code></pre>
<p>最后返回<code>right</code>或<code>left</code>均可。</p>
<p>注意：这里和C++写法存在较大差异。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="旋转数组"><a class="header" href="#旋转数组">旋转数组</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="matrix"><a class="header" href="#matrix">Matrix</a></h1>
<ul>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#48-rotate-image">48. Rotate Image</a>
<ul>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#%E6%80%9D%E8%B7%AF">思路</a>
<ul>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C">核心操作</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#summary">Summary</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#c-%E8%A7%A3%E6%B3%95">C++ 解法</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#java-%E8%A7%A3%E6%B3%95">Java 解法</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#python-%E8%A7%A3%E6%B3%95">Python 解法</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#54-spiral-matrix">54. Spiral Matrix</a>
<ul>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#%E6%80%9D%E8%B7%AF-1">思路</a>
<ul>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#%E6%96%B9%E6%B3%95%E4%B8%80%E6%A8%A1%E6%8B%9F">方法一：模拟</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#%E6%96%B9%E6%B3%95%E4%BA%8C%E6%8C%89%E5%B1%82%E6%A8%A1%E6%8B%9F">方法二：按层模拟</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#c-%E8%A7%A3%E6%B3%95-1">C++ 解法</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#java-%E8%A7%A3%E6%B3%95-1">Java 解法</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#python3-%E8%A7%A3%E6%B3%95">Python3 解法</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#73-set-matrix-zeroes">73. Set Matrix Zeroes</a>
<ul>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#%E6%80%9D%E8%B7%AF-2">思路</a>
<ul>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#%E6%96%B9%E6%B3%95%E4%B8%80%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%87%E8%AE%B0%E6%95%B0%E7%BB%84">方法一：使用两个标记数组</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%87%E8%AE%B0%E5%8F%98%E9%87%8F">方法二：使用两个标记变量</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#%E6%96%B9%E6%B3%95%E4%B8%89%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%87%E8%AE%B0%E5%8F%98%E9%87%8F">方法三：使用一个标记变量</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#c-%E8%A7%A3%E6%B3%95-2">C++ 解法</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#java-%E8%A7%A3%E6%B3%95-2">Java 解法</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#python3-%E8%A7%A3%E6%B3%95-1">Python3 解法</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#240-search-a-2d-matrix-ii">240. Search a 2D Matrix II</a>
<ul>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#%E6%80%9D%E8%B7%AF-3">思路</a>
<ul>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#%E6%96%B9%E6%B3%95%E4%B8%80%E7%9B%B4%E6%8E%A5%E6%9F%A5%E6%89%BE">方法一：直接查找</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">方法二：二分查找</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#%E6%96%B9%E6%B3%95%E4%B8%89z-%E5%AD%97%E5%BD%A2%E6%9F%A5%E6%89%BE">方法三：Z 字形查找</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#c-%E8%A7%A3%E6%B3%95-3">C++ 解法</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#java-%E8%A7%A3%E6%B3%95-3">Java 解法</a></li>
<li><a href="%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5.html#python-%E8%A7%A3%E6%B3%95-1">Python 解法</a></li>
</ul>
</li>
</ul>
<h1 id="48-rotate-image"><a class="header" href="#48-rotate-image"><a href="https://leetcode.com/problems/rotate-image/">48. Rotate Image</a></a></h1>
<p>You are given an <code>n x n</code> 2D <code>matrix</code> representing an image, rotate the image by <strong>90</strong> degrees (clockwise).</p>
<p>You have to rotate the image <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="" /></p>
<p><strong>Input:</strong> <code>matrix = [[1,2,3],[4,5,6],[7,8,9]]</code><br />
<strong>Output:</strong> <code>[[7,4,1],[8,5,2],[9,6,3]]</code></p>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt="" /></p>
<p><strong>Input:</strong> <code>matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</code><br />
<strong>Output:</strong> <code>[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</code></p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>n == matrix.length == matrix[i].length</code></li>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>
</ul>
<h2 id="思路-4"><a class="header" href="#思路-4">思路</a></h2>
<p><strong>Input:</strong> <code>matrix = [[1,2,3],[4,5,6],[7,8,9]]</code></p>
<p>先以上下分界线对称交换两行，此时矩阵如下所示：</p>
<p><code>matrix = [[7,8,9],[4,5,6],[1,2,3]]</code></p>
<p>主对角线位置上的元素被放置到合适的位置</p>
<p>最后交换主对角线两侧的元素得到最终结果。</p>
<p><strong>Output:</strong> <code>[[7,4,1],[8,5,2],[9,6,3]]</code></p>
<h3 id="核心操作"><a class="header" href="#核心操作">核心操作</a></h3>
<p><strong>Vertical Flip</strong>:</p>
<ul>
<li>The first part of the algorithm vertically flips the matrix. It swaps the elements in the top row with the corresponding elements in the bottom row, moving towards the center row.</li>
<li>Example before vertical flip (3x3 matrix):</li>
</ul>
<pre><code>1 2 3
4 5 6
7 8 9
</code></pre>
<ul>
<li>Example after vertical flip:</li>
</ul>
<pre><code>7 8 9
4 5 6
1 2 3
</code></pre>
<p><strong>Transpose</strong>:</p>
<ul>
<li>The second part of the algorithm transposes the matrix. It swaps the elements at positions <code>[i][j]</code> with the elements at <code>[j][i]</code>, effectively turning rows into columns and vice versa.</li>
<li>Example after transpose:</li>
</ul>
<pre><code>7 4 1
8 5 2
9 6 3
</code></pre>
<p>Combining these two operations results in rotating the matrix by 90 degrees clockwise.</p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>This algorithm efficiently rotates a matrix by 90 degrees clockwise by first flipping it vertically and then transposing it. This approach leverages the properties of matrix operations to achieve the desired transformation with minimal code complexity.</p>
<h2 id="c-解法-2"><a class="header" href="#c-解法-2">C++ 解法</a></h2>
<h2 id="java-解法-3"><a class="header" href="#java-解法-3">Java 解法</a></h2>
<pre><code class="language-java">class Solution {
    public void rotate(int[][] matrix) {
        int top = 0, bottom = matrix.length - 1;
        while(top &lt; bottom){
            for(int i = 0; i &lt; matrix[0].length; i++){
                int temp = matrix[top][i];
                matrix[top][i] = matrix[bottom][i];
                matrix[bottom][i] = temp;
            }
            top++;
            bottom--;
        }
        for(int row = 0; row &lt; matrix.length; row++){
            for(int col = row + 1; col &lt; matrix[0].length; col++){
                int temp = matrix[row][col];
                matrix[row][col] = matrix[col][row];
                matrix[col][row] = temp;
            }
        }
    }
}
</code></pre>
<h2 id="python-解法-3"><a class="header" href="#python-解法-3">Python 解法</a></h2>
<h1 id="54-spiral-matrix"><a class="header" href="#54-spiral-matrix"><a href="https://leetcode.com/problems/spiral-matrix/">54. Spiral Matrix</a></a></h1>
<p>Given an <code>m x n</code> <code>matrix</code>, return <em>all elements of the</em> <code>matrix</code> <em>in spiral order</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="" /></p>
<p><strong>Input:</strong> <code>matrix = [[1,2,3],[4,5,6],[7,8,9]]</code><br />
<strong>Output:</strong> <code>[1,2,3,6,9,8,7,4,5]</code></p>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="" /></p>
<p><strong>Input:</strong> <code>matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</code><br />
<strong>Output:</strong> <code>[1,2,3,4,8,12,11,10,9,5,6,7]</code></p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10</code></li>
<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>
</ul>
<h2 id="思路-5"><a class="header" href="#思路-5">思路</a></h2>
<p>注意：这里不一定是一个方阵</p>
<h3 id="方法一模拟"><a class="header" href="#方法一模拟">方法一：模拟</a></h3>
<p>可以模拟螺旋矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向。</p>
<p>判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 visited，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 visited 中的对应位置的元素设为已访问。</p>
<p>如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。</p>
<p>复杂度分析</p>
<p>时间复杂度：O(mn)，其中 m 和 n 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。</p>
<p>空间复杂度：O(mn)。需要创建一个大小为 m×n 的矩阵 visited 记录每个位置是否被访问过。</p>
<h3 id="方法二按层模拟"><a class="header" href="#方法二按层模拟">方法二：按层模拟</a></h3>
<p>可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。</p>
<p>定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，剩下的元素都是第 3 层。</p>
<pre><code>[[1, 1, 1, 1, 1, 1, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 2, 3, 3, 3, 2, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 1, 1, 1, 1, 1, 1]]
</code></pre>
<p>对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于 (top,left)，右下角位于 (bottom,right)，按照如下顺序遍历当前层的元素。</p>
<p>从左到右遍历上侧元素，依次为 (top,left) 到 (top,right)。</p>
<p>从上到下遍历右侧元素，依次为 (top+1,right) 到 (bottom,right)。</p>
<p>如果 left&lt;right 且 top&lt;bottom，则从右到左遍历下侧元素，依次为 (bottom,right−1) 到 (bottom,left+1)，以及从下到上遍历左侧元素，依次为 (bottom,left) 到 (top+1,left)。</p>
<p>遍历完当前层的元素之后，将 left 和 top 分别增加 1，将 right 和 bottom 分别减少 1，进入下一层继续遍历，直到遍历完所有元素为止。</p>
<p>复杂度分析</p>
<p>时间复杂度：O(mn)，其中 m 和 n 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。</p>
<p>空间复杂度：O(1)。除了输出数组以外，空间复杂度是常数。</p>
<p>作者：力扣官方题解
链接： https://leetcode.cn/problems/spiral-matrix/solutions/275393/luo-xuan-ju-zhen-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="c-解法-3"><a class="header" href="#c-解法-3">C++ 解法</a></h2>
<p>方法二：按层模拟</p>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0) {
            return {};
        }

        int rows = matrix.size(), columns = matrix[0].size();
        vector&lt;int&gt; order;
        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
        while (left &lt;= right &amp;&amp; top &lt;= bottom) {
            for (int column = left; column &lt;= right; column++) {
                order.push_back(matrix[top][column]);
            }
            for (int row = top + 1; row &lt;= bottom; row++) {
                order.push_back(matrix[row][right]);
            }
            if (left &lt; right &amp;&amp; top &lt; bottom) {
                for (int column = right - 1; column &gt; left; column--) {
                    order.push_back(matrix[bottom][column]);
                }
                for (int row = bottom; row &gt; top; row--) {
                    order.push_back(matrix[row][left]);
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
        return order;
    }
};
</code></pre>
<h2 id="java-解法-4"><a class="header" href="#java-解法-4">Java 解法</a></h2>
<p>方法二：按层模拟</p>
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; spiralOrder(int[][] matrix) {
        List&lt;Integer&gt; order = new ArrayList&lt;Integer&gt;();
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return order;
        }
        int rows = matrix.length, columns = matrix[0].length;
        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
        while (left &lt;= right &amp;&amp; top &lt;= bottom) {
            for (int column = left; column &lt;= right; column++) {
                order.add(matrix[top][column]);
            }
            for (int row = top + 1; row &lt;= bottom; row++) {
                order.add(matrix[row][right]);
            }
            if (left &lt; right &amp;&amp; top &lt; bottom) {
                for (int column = right - 1; column &gt; left; column--) {
                    order.add(matrix[bottom][column]);
                }
                for (int row = bottom; row &gt; top; row--) {
                    order.add(matrix[row][left]);
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
        return order;
    }
}
</code></pre>
<h2 id="python3-解法"><a class="header" href="#python3-解法">Python3 解法</a></h2>
<p>方法一：模拟</p>
<pre><code class="language-python">class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:
        if not matrix or not matrix[0]:
            return list()
        
        rows, columns = len(matrix), len(matrix[0])
        visited = [[False] * columns for _ in range(rows)]
        total = rows * columns
        order = [0] * total

        directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        row, column = 0, 0
        directionIndex = 0
        for i in range(total):
            order[i] = matrix[row][column]
            visited[row][column] = True
            nextRow, nextColumn = row + directions[directionIndex][0], column + directions[directionIndex][1]
            if not (0 &lt;= nextRow &lt; rows and 0 &lt;= nextColumn &lt; columns and not visited[nextRow][nextColumn]):
                directionIndex = (directionIndex + 1) % 4
            row += directions[directionIndex][0]
            column += directions[directionIndex][1]
        return order
</code></pre>
<h1 id="73-set-matrix-zeroes"><a class="header" href="#73-set-matrix-zeroes"><a href="https://leetcode.com/problems/set-matrix-zeroes/">73. Set Matrix Zeroes</a></a></h1>
<p>Given an <code>m x n</code> integer matrix <code>matrix</code>, if an element is <code>0</code>, set its entire row and column to <code>0</code>'s.</p>
<p>You must do it <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in place</a>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt="" /></p>
<p><strong>Input:</strong> <code>matrix = [[1,1,1],[1,0,1],[1,1,1]]</code><br />
<strong>Output:</strong> <code>[[1,0,1],[0,0,0],[1,0,1]]</code></p>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt="" /></p>
<p><strong>Input:</strong> <code>matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</code><br />
<strong>Output:</strong> <code>[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</code></p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[0].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>-2^31 &lt;= matrix[i][j] &lt;= 2^31 - 1</code></li>
</ul>
<p><strong>Follow up:</strong></p>
<ul>
<li>A straightforward solution using <code>O(mn)</code> space is probably a bad idea.</li>
<li>A simple improvement uses <code>O(m + n)</code> space, but still not the best solution.</li>
<li>Could you devise a constant space solution?</li>
</ul>
<h2 id="思路-6"><a class="header" href="#思路-6">思路</a></h2>
<h3 id="方法一使用两个标记数组"><a class="header" href="#方法一使用两个标记数组">方法一：使用两个标记数组</a></h3>
<p>思路和算法</p>
<p>我们可以用两个标记数组分别记录每一行和每一列是否有零出现。</p>
<p>具体地，我们首先遍历该数组一次，如果某个元素为 0，那么就将该元素所在的行和列所对应标记数组的位置置为 true。最后我们再次遍历该数组，用标记数组更新原数组即可。</p>
<p>复杂度分析</p>
<p>时间复杂度：O(mn)，其中 m 是矩阵的行数，n 是矩阵的列数。我们至多只需要遍历该矩阵两次。</p>
<p>空间复杂度：O(m+n)，其中 m 是矩阵的行数，n 是矩阵的列数。我们需要分别记录每一行或每一列是否有零出现。</p>
<h3 id="方法二使用两个标记变量"><a class="header" href="#方法二使用两个标记变量">方法二：使用两个标记变量</a></h3>
<p>思路和算法</p>
<p>我们可以用矩阵的第一行和第一列代替方法一中的两个标记数组，以达到 O(1) 的额外空间。但这样会导致原数组的第一行和第一列被修改，无法记录它们是否原本包含 0。因此我们需要额外使用两个标记变量分别记录第一行和第一列是否原本包含 0。</p>
<p>在实际代码中，我们首先预处理出两个标记变量，接着使用其他行与列去处理第一行与第一列，然后反过来使用第一行与第一列去更新其他行与列，最后使用两个标记变量更新第一行与第一列即可。</p>
<p>复杂度分析</p>
<p>时间复杂度：O(mn)，其中 m 是矩阵的行数，n 是矩阵的列数。我们至多只需要遍历该矩阵两次。</p>
<p>空间复杂度：O(1)。我们只需要常数空间存储若干变量。</p>
<h3 id="方法三使用一个标记变量"><a class="header" href="#方法三使用一个标记变量">方法三：使用一个标记变量</a></h3>
<p>思路和算法</p>
<p>我们可以对方法二进一步优化，只使用一个标记变量记录第一列是否原本存在 0。这样，第一列的第一个元素即可以标记第一行是否出现 0。但为了防止每一列的第一个元素被提前更新，我们需要从最后一行开始，倒序地处理矩阵元素。</p>
<p>复杂度分析</p>
<p>时间复杂度：O(mn)，其中 m 是矩阵的行数，n 是矩阵的列数。我们至多只需要遍历该矩阵两次。</p>
<p>空间复杂度：O(1)。我们只需要常数空间存储若干变量。</p>
<p>作者：力扣官方题解
链接：https://leetcode.cn/problems/set-matrix-zeroes/solutions/669901/ju-zhen-zhi-ling-by-leetcode-solution-9ll7/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="c-解法-4"><a class="header" href="#c-解法-4">C++ 解法</a></h2>
<p>方法二：使用两个标记变量</p>
<pre><code class="language-cpp">class Solution {
public:
    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        int flag_col0 = false, flag_row0 = false;

        for (int i = 0; i &lt; m; i++) {
            if (!matrix[i][0]) {
                flag_col0 = true;
            }
        }
        for (int j = 0; j &lt; n; j++) {
            if (!matrix[0][j]) {
                flag_row0 = true;
            }
        }

        for(int i = 1; i &lt; m; i++){
            for(int j = 1; j &lt; n; j++){
                if(matrix[i][j] == 0){
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                if (!matrix[i][0] || !matrix[0][j]) {
                    matrix[i][j] = 0;
                }
            }
        }
        if (flag_col0) {
            for (int i = 0; i &lt; m; i++) {
                matrix[i][0] = 0;
            }
        }
        if (flag_row0) {
            for (int j = 0; j &lt; n; j++) {
                matrix[0][j] = 0;
            }
        }
    }
};
</code></pre>
<h2 id="java-解法-5"><a class="header" href="#java-解法-5">Java 解法</a></h2>
<p>方法一：使用两个标记数组</p>
<pre><code class="language-java">class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;

        boolean[] row = new boolean[m];
        boolean[] col = new boolean[n];

        for(int i = 0; i &lt; m; i++){
            for(int j = 0; j &lt; n; j++){
                if(matrix[i][j] == 0){
                    row[i] = true;
                    col[j] = true;
                }
            }
        }
        for(int i = 0; i &lt; m; i++){
            for(int j = 0; j &lt; n; j++){
                if(row[i] || col[j]){
                    matrix[i][j] = 0;
                }
            }
        }
    }
}
</code></pre>
<h2 id="python3-解法-1"><a class="header" href="#python3-解法-1">Python3 解法</a></h2>
<p>方法三：使用一个标记变量</p>
<pre><code class="language-python">class Solution:
    def setZeroes(self, matrix: List[List[int]]) -&gt; None:
        m, n = len(matrix), len(matrix[0])
        flag_col0 = False
        
        for i in range(m):
            if matrix[i][0] == 0:
                flag_col0 = True
            for j in range(1, n):
                if matrix[i][j] == 0:
                    matrix[i][0] = matrix[0][j] = 0
        
        for i in range(m - 1, -1, -1):
            for j in range(1, n):
                if matrix[i][0] == 0 or matrix[0][j] == 0:
                    matrix[i][j] = 0
            if flag_col0:
                matrix[i][0] = 0
</code></pre>
<h1 id="240-search-a-2d-matrix-ii"><a class="header" href="#240-search-a-2d-matrix-ii"><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/">240. Search a 2D Matrix II</a></a></h1>
<p>Write an efficient algorithm that searches for a value <code>target</code> in an <code>m x n</code> integer matrix <code>matrix</code>. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted in ascending from left to right.</li>
<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg" alt="" /></p>
<p><strong>Input:</strong> <code>matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5</code><br />
<strong>Output:</strong> true</p>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg" alt="" /></p>
<p><strong>Input:</strong> <code>matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20</code><br />
<strong>Output:</strong> false</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= n, m &lt;= 300</code></li>
<li><code>-10^9 &lt;= matrix[i][j] &lt;= 10^9</code></li>
<li>All the integers in each row are <strong>sorted</strong> in ascending order.</li>
<li>All the integers in each column are <strong>sorted</strong> in ascending order.</li>
<li><code>-10^9 &lt;= target &lt;= 10^9</code></li>
</ul>
<h2 id="思路-7"><a class="header" href="#思路-7">思路</a></h2>
<h3 id="方法一直接查找"><a class="header" href="#方法一直接查找">方法一：直接查找</a></h3>
<p>思路与算法</p>
<p>我们直接遍历整个矩阵 matrix，判断 target 是否出现即可。</p>
<p>复杂度分析</p>
<p>时间复杂度：O(mn)。</p>
<p>空间复杂度：O(1)。</p>
<h3 id="方法二二分查找"><a class="header" href="#方法二二分查找">方法二：二分查找</a></h3>
<p>思路与算法</p>
<p>由于矩阵 matrix 中每一行的元素都是升序排列的，因此我们可以对每一行都使用一次二分查找，判断 target 是否在该行中，从而判断 target 是否出现。</p>
<p>复杂度分析</p>
<p>时间复杂度：O(mlogn)。对一行使用二分查找的时间复杂度为 O(logn)，最多需要进行 m 次二分查找。</p>
<p>空间复杂度：O(1)。</p>
<h3 id="方法三z-字形查找"><a class="header" href="#方法三z-字形查找">方法三：Z 字形查找</a></h3>
<p>思路与算法</p>
<p>我们可以从矩阵 matrix 的右上角 (0,n−1) 进行搜索。在每一步的搜索过程中，如果我们位于位置 (x,y)，那么我们希望在以 matrix 的左下角为左下角、以 (x,y) 为右上角的矩阵中进行搜索，即行的范围为 <code>[x,m−1]</code>，列的范围为 <code>[0,y]</code>：</p>
<p>如果 <code>matrix[x,y]=target</code>，说明搜索完成；</p>
<p>如果 <code>matrix[x,y]&gt;target</code>，由于每一列的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于第 y 列的元素都是严格大于 target 的，因此我们可以将它们全部忽略，即将 y 减少 1；</p>
<p>如果 <code>matrix[x,y]&lt;target</code>，由于每一行的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于第 x 行的元素都是严格小于 target 的，因此我们可以将它们全部忽略，即将 x 增加 1。</p>
<p>在搜索的过程中，如果我们超出了矩阵的边界，那么说明矩阵中不存在 target。</p>
<p>复杂度分析</p>
<p>时间复杂度：O(m+n)。在搜索的过程中，如果我们没有找到 target，那么我们要么将 y 减少 1，要么将 x 增加 1。由于 (x,y) 的初始值分别为 (0,n−1)，因此 y 最多能被减少 n 次，x 最多能被增加 m 次，总搜索次数为 m+n。在这之后，x 和 y 就会超出矩阵的边界。</p>
<p>空间复杂度：O(1)。</p>
<p>作者：力扣官方题解
链接： https://leetcode.cn/problems/search-a-2d-matrix-ii/solutions/1062538/sou-suo-er-wei-ju-zhen-ii-by-leetcode-so-9hcx/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="c-解法-5"><a class="header" href="#c-解法-5">C++ 解法</a></h2>
<p>方法二：二分查找</p>
<pre><code class="language-cpp">class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
        for (const auto&amp; row: matrix) {
            auto it = lower_bound(row.begin(), row.end(), target);
            if (it != row.end() &amp;&amp; *it == target) {
                return true;
            }
        }
        return false;
    }
};
</code></pre>
<h2 id="java-解法-6"><a class="header" href="#java-解法-6">Java 解法</a></h2>
<p>方法三：Z 字形查找</p>
<pre><code class="language-java">class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length, n = matrix[0].length;
        int x = 0, y = n - 1;
        while (x &lt; m &amp;&amp; y &gt;= 0) {
            if (matrix[x][y] == target) {
                return true;
            }
            if (matrix[x][y] &gt; target) {
                --y;
            } else {
                ++x;
            }
        }
        return false;
    }
}
</code></pre>
<h2 id="python-解法-4"><a class="header" href="#python-解法-4">Python 解法</a></h2>
<p>方法一：直接查找</p>
<pre><code class="language-python">class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:
        for row in matrix:
            for element in row:
                if element == target:
                    return True
        return False
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="链表"><a class="header" href="#链表">链表</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="206-reverse-linked-list"><a class="header" href="#206-reverse-linked-list"><a href="https://leetcode.com/problems/reverse-linked-list/">206. Reverse Linked List</a></a></h1>
<ul>
<li><a href="%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html#description">Description</a></li>
<li><a href="%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html#%E6%80%9D%E8%B7%AF">思路</a></li>
<li><a href="%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html#c-%E8%A7%A3%E6%B3%95">C++ 解法</a></li>
<li><a href="%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html#java-%E8%A7%A3%E6%B3%95">Java 解法</a></li>
<li><a href="%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html#python-%E8%A7%A3%E6%B3%95">Python 解法</a></li>
</ul>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="" /></p>
<p><strong>Input:</strong> <code>head = [1,2,3,4,5]</code><br />
<strong>Output:</strong> <code>[5,4,3,2,1]</code></p>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="" /></p>
<p><strong>Input:</strong> <code>head = [1,2]</code><br />
<strong>Output:</strong> <code>[2,1]</code></p>
<p><strong>Example 3:</strong></p>
<p><strong>Input:</strong> <code>head = []</code><br />
<strong>Output:</strong> <code>[]</code></p>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is the range <code>[0, 5000]</code>.</li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>Follow up:</strong> A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<h2 id="思路-8"><a class="header" href="#思路-8">思路</a></h2>
<p>双指针</p>
<p>迭代</p>
<p>递归</p>
<h2 id="c-解法-6"><a class="header" href="#c-解法-6">C++ 解法</a></h2>
<p>递归</p>
<pre><code class="language-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head == NULL || head-&gt;next == NULL)
            return head;
        ListNode* last = reverseList(head-&gt;next);
        head-&gt;next-&gt;next = head;
        head-&gt;next = NULL;
        return last; 
    }
};
</code></pre>
<h2 id="java-解法-7"><a class="header" href="#java-解法-7">Java 解法</a></h2>
<p>迭代</p>
<pre><code class="language-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null){
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
</code></pre>
<h2 id="python-解法-5"><a class="header" href="#python-解法-5">Python 解法</a></h2>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="哈希表"><a class="header" href="#哈希表">哈希表</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="字符串"><a class="header" href="#字符串">字符串</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="双指针"><a class="header" href="#双指针">双指针</a></h1>
<p>双指针法是一种常用的解决编程问题的技巧，它通常分为快慢指针和左右指针两种类型。</p>
<h2 id="左右指针"><a class="header" href="#左右指针">左右指针</a></h2>
<ul>
<li>左右双指针通常用于解决数组或字符串相关问题，例如寻找两数之和、反转字符串等。</li>
<li>典型应用：求解数组或字符串相关问题。左右双指针可以在不同方向上同时进行移动，并通过特定条件来更新左右边界。</li>
</ul>
<h2 id="快慢指针"><a class="header" href="#快慢指针">快慢指针</a></h2>
<ul>
<li>快慢指针法通常用于解决链表中的问题，如判定链表中是否有环、找到链表的中间节点等。快指针每次移动两步，慢指针每次移动一步。</li>
<li>典型应用：判断链表是否有环。当存在环时，快慢指针最终会相遇；找到链表中间节点时，快指针到达末尾时慢指针正好在中间位置。</li>
</ul>
<p>总结来说，在编程中使用双指针法可帮助我们降低时间复杂度，并且适合处理循环、交错等特殊情况。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="移动元素"><a class="header" href="#移动元素">移动元素</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="三数之和"><a class="header" href="#三数之和">三数之和</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="接雨水"><a class="header" href="#接雨水">接雨水</a></h1>
<ul>
<li><a href="%E5%8F%8C%E6%8C%87%E9%92%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4.html#11-container-with-most-water">11. Container With Most Water</a>
<ul>
<li><a href="%E5%8F%8C%E6%8C%87%E9%92%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4.html#%E6%80%9D%E8%B7%AF">思路</a></li>
<li><a href="%E5%8F%8C%E6%8C%87%E9%92%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4.html#c-%E8%A7%A3%E6%B3%95">C++ 解法</a></li>
<li><a href="%E5%8F%8C%E6%8C%87%E9%92%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4.html#java-%E8%A7%A3%E6%B3%95">Java 解法</a></li>
<li><a href="%E5%8F%8C%E6%8C%87%E9%92%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4.html#python-%E8%A7%A3%E6%B3%95">Python 解法</a></li>
</ul>
</li>
<li><a href="%E5%8F%8C%E6%8C%87%E9%92%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4.html#42-trapping-rain-water">42. Trapping Rain Water</a>
<ul>
<li><a href="%E5%8F%8C%E6%8C%87%E9%92%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4.html#%E6%80%9D%E8%B7%AF-1">思路</a></li>
<li><a href="%E5%8F%8C%E6%8C%87%E9%92%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4.html#c-%E8%A7%A3%E6%B3%95-1">C++ 解法</a></li>
<li><a href="%E5%8F%8C%E6%8C%87%E9%92%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4.html#java-%E8%A7%A3%E6%B3%95-1">Java 解法</a></li>
<li><a href="%E5%8F%8C%E6%8C%87%E9%92%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4.html#python-%E8%A7%A3%E6%B3%95-1">Python 解法</a></li>
</ul>
</li>
</ul>
<h1 id="11-container-with-most-water"><a class="header" href="#11-container-with-most-water"><a href="https://leetcode.com/problems/container-with-most-water/">11. Container With Most Water</a></a></h1>
<p>You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>ith</code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.</p>
<p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p>
<p>Return <em>the maximum amount of water a container can store</em>.</p>
<p><strong>Notice</strong> that you may not slant the container.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="" /></p>
<p><strong>Input:</strong> <code>height = [1,8,6,2,5,4,8,3,7]</code><br />
<strong>Output:</strong> 49<br />
<strong>Explanation:</strong> The above vertical lines are represented by array <code>[1,8,6,2,5,4,8,3,7]</code>. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> <code>height = [1,1]</code><br />
<strong>Output:</strong> 1</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>2 &lt;= n &lt;= 10^5</code></li>
<li><code>0 &lt;= height[i] &lt;= 10^4</code></li>
</ul>
<h2 id="思路-9"><a class="header" href="#思路-9">思路</a></h2>
<p>双指针，左低移左，右低移右</p>
<p>The two-pointer technique starts with the widest container and moves the pointers inward based on the comparison of heights.</p>
<p>Increasing the width of the container can only lead to a larger area if the height of the new boundary is greater. By moving the pointers towards the center, we explore containers with the potential for greater areas.</p>
<h2 id="c-解法-7"><a class="header" href="#c-解法-7">C++ 解法</a></h2>
<pre><code class="language-cpp">class Solution {
public:
    int maxArea(vector&lt;int&gt;&amp; height) {
        int left = 0;
        int right = height.size() - 1;
        int maxArea = 0;

        while (left &lt; right) {
            int currentArea = min(height[left], height[right]) * (right - left);
            maxArea = max(maxArea, currentArea);

            if (height[left] &lt; height[right]) {
                left++;
            } else {
                right--;
            }
        }

        return maxArea;
    }
};
</code></pre>
<h2 id="java-解法-8"><a class="header" href="#java-解法-8">Java 解法</a></h2>
<pre><code class="language-java">class Solution {
    public int maxArea(int[] height) {
        int result = 0;
        int left = 0; 
        int right = height.length - 1;
        while(left &lt;= right){
            result = Math.max(result, Math.min(height[right],height[left])*(right-left));
            if(height[right] &lt; height[left]) right--;
            else left++;
        }
        return result;
    }
}
</code></pre>
<h2 id="python-解法-6"><a class="header" href="#python-解法-6">Python 解法</a></h2>
<pre><code class="language-python">class Solution:
    def maxArea(self, height: List[int]) -&gt; int:
        left = 0
        right = len(height) - 1
        maxArea = 0

        while left &lt; right:
            currentArea = min(height[left], height[right]) * (right - left)
            maxArea = max(maxArea, currentArea)

            if height[left] &lt; height[right]:
                left += 1
            else:
                right -= 1

        return maxArea
</code></pre>
<h1 id="42-trapping-rain-water"><a class="header" href="#42-trapping-rain-water"><a href="https://leetcode.com/problems/trapping-rain-water/">42. Trapping Rain Water</a></a></h1>
<p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="" /></p>
<p><strong>Input:</strong> <code>height = [0,1,0,2,1,0,1,3,2,1,2,1]</code><br />
<strong>Output:</strong> 6<br />
<strong>Explanation:</strong> The above elevation map (black section) is represented by array <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>. In this case, 6 units of rain water (blue section) are being trapped.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> <code>height = [4,2,0,3,2,5]</code><br />
<strong>Output:</strong> 9</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>1 &lt;= n &lt;= 2 * 10^4</code></li>
<li><code>0 &lt;= height[i] &lt;= 10^5</code></li>
</ul>
<h2 id="思路-10"><a class="header" href="#思路-10">思路</a></h2>
<p>一共三种解法：双指针、单调栈和动态规划。</p>
<h2 id="c-解法-8"><a class="header" href="#c-解法-8">C++ 解法</a></h2>
<p>单调栈</p>
<pre><code class="language-cpp">class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        if(height.size() &lt;= 2) return 0;
        int result = 0;
        stack&lt;int&gt; st;
        st.push(0);
        for(int i = 1; i &lt; height.size(); i++){
            if(height[i] &lt; height[st.top()]){
                st.push(i);
            }else if(height[i] == height[st.top()]){
                st.push(i);
            }else{
               while(!st.empty() &amp;&amp; height[i] &gt; height[st.top()]){
                    int mid = st.top();
                    st.pop();
                    if(!st.empty()){
                        int h = min(height[i], height[st.top()]) - height[mid];
                        int w = i - st.top() - 1;
                        result += h * w;
                    }
               }
               st.push(i);
            }
        }
        return result;
    }
};
</code></pre>
<h2 id="java-解法-9"><a class="header" href="#java-解法-9">Java 解法</a></h2>
<p>双指针</p>
<pre><code class="language-java">class Solution {
    public int trap(int[] height) {
        int i=0,left_max=height[0];
        int sum=0;
        int j=height.length-1,right_max=height[j];
        while(i &lt; j){
            if(left_max &lt;= right_max){
                sum += left_max - height[i];
                i++;
                left_max = Math.max(left_max, height[i]);
            }else{
                sum += right_max - height[j];
                j--;
                right_max = Math.max(right_max, height[j]);
            }
        }
        return sum;
    }
}
</code></pre>
<h2 id="python-解法-7"><a class="header" href="#python-解法-7">Python 解法</a></h2>
<p>双指针</p>
<pre><code class="language-python">class Solution:
    def trap(self, height: List[int]) -&gt; int:
        i = 0
        left_max = height[0]
        sum = 0
        j = len(height) - 1
        right_max = height[j]
        while i &lt; j:
            if left_max &lt;= right_max:
                sum += left_max - height[i]
                i += 1
                left_max = max(left_max, height[i])
            else:
                sum += right_max - height[j]
                j -= 1
                right_max = max(right_max, height[j])
        return sum
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="栈与队列"><a class="header" href="#栈与队列">栈与队列</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="二叉树"><a class="header" href="#二叉树">二叉树</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="二叉树遍历"><a class="header" href="#二叉树遍历">二叉树遍历</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="路径之和"><a class="header" href="#路径之和">路径之和</a></h1>
<ul>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C.html#437-path-sum-iii">437. Path Sum III</a>
<ul>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF">思路</a>
<ul>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C.html#%E6%96%B9%E6%B3%95%E4%B8%80%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">方法一：深度优先搜索</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C.html#%E6%96%B9%E6%B3%95%E4%BA%8C-%E5%89%8D%E7%BC%80%E5%92%8C">方法二: 前缀和</a></li>
</ul>
</li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C.html#c-%E8%A7%A3%E6%B3%95">C++ 解法</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C.html#java-%E8%A7%A3%E6%B3%95">Java 解法</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C.html#python-%E8%A7%A3%E6%B3%95">Python 解法</a></li>
</ul>
</li>
</ul>
<h1 id="437-path-sum-iii"><a class="header" href="#437-path-sum-iii"><a href="https://leetcode.com/problems/path-sum-iii/">437. Path Sum III</a></a></h1>
<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <em>the number of paths where the sum of the values along the path equals</em> <code>targetSum</code>.</p>
<p>The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" alt="" /></p>
<p><strong>Input:</strong> <code>root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8</code><br />
<strong>Output:</strong> 3<br />
<strong>Explanation:</strong> The paths that sum to 8 are shown.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> <code>root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</code><br />
<strong>Output:</strong> 3</p>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 1000]</code>.</li>
<li><code>-10^9 &lt;= Node.val &lt;= 10^9</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<h2 id="思路-11"><a class="header" href="#思路-11">思路</a></h2>
<h3 id="方法一深度优先搜索"><a class="header" href="#方法一深度优先搜索">方法一：深度优先搜索</a></h3>
<p>思路与算法</p>
<p>我们首先想到的解法是穷举所有的可能，我们访问每一个节点 node，检测以 node 为起始节点且向下延深的路径有多少种。我们递归遍历每一个节点的所有可能的路径，然后将这些路径数目加起来即为返回结果。</p>
<ul>
<li>我们首先定义 rootSum(p,val) 表示以节点 p 为起点向下且满足路径总和为 val 的路径数目。我们对二叉树上每个节点 p 求出 rootSum(p,targetSum)，然后对这些路径数目求和即为返回结果。</li>
<li>我们对节点 p 求 rootSum(p,targetSum) 时，以当前节点 p 为目标路径的起点递归向下进行搜索。假设当前的节点 p 的值为 val，我们对左子树和右子树进行递归搜索，对节点 p 的左孩子节点 pl 求出 rootSum(pl,targetSum−val)，以及对右孩子节点 pr求出 rootSum(pr ,targetSum−val)。节点 p 的 rootSum(p,targetSum) 即等于 rootSum(pl,targetSum−val) 与 rootSum(p,targetSum−val) 之和，同时我们还需要判断一下当前节点 p 的值是否刚好等于 targetSum。</li>
<li>我们采用递归遍历二叉树的每个节点 p，对节点 p 求 rootSum(p,val)，然后将每个节点所有求的值进行相加求和返回。</li>
</ul>
<p>复杂度分析</p>
<p>时间复杂度：O(N^2 )，其中 N 为该二叉树节点的个数。对于每一个节点，求以该节点为起点的路径数目时，则需要遍历以该节点为根节点的子树的所有节点，因此求该路径所花费的最大时间为 O(N)，我们会对每个节点都求一次以该节点为起点的路径数目，因此时间复杂度为 O(N^2)。</p>
<p>空间复杂度：O(N)，考虑到递归需要在栈上开辟空间。</p>
<h3 id="方法二-前缀和"><a class="header" href="#方法二-前缀和">方法二: 前缀和</a></h3>
<p>思路与算法</p>
<p>我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点 root 到当前节点 p 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 curr 减去 targetSum。</p>
<ul>
<li>对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为 0。</li>
<li>假设根节点为 root，我们当前刚好访问节点 node，则此时从根节点 root 到节点 node 的路径（无重复节点）刚好为 root→p1→p2→…→pk→node，此时我们可以已经保存了节点 p1,p2,p3 ,…,pk的前缀和，并且计算出了节点 node 的前缀和。</li>
<li>假设当前从根节点 root 到节点 node 的前缀和为 curr，则此时我们在已保存的前缀和查找是否存在前缀和刚好等于 curr−targetSum。假设从根节点 root 到节点 node 的路径中存在节点 pi到根节点 root 的前缀和为 curr−targetSum，则节点 pi+1到 node 的路径上所有节点的和一定为 targetSum。</li>
<li>我们利用深度搜索遍历树，当我们退出当前节点时，我们需要及时更新已经保存的前缀和。</li>
</ul>
<p>复杂度分析</p>
<p>时间复杂度：O(N)，其中 N 为二叉树中节点的个数。利用前缀和只需遍历一次二叉树即可。</p>
<p>空间复杂度：O(N)。</p>
<p>作者：力扣官方题解
链接： https://leetcode.cn/problems/path-sum-iii/solutions/1021296/lu-jing-zong-he-iii-by-leetcode-solution-z9td/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="c-解法-9"><a class="header" href="#c-解法-9">C++ 解法</a></h2>
<p>深度优先搜索</p>
<pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int rootSum(TreeNode* root, long targetSum){
        if(!root) return 0;
        int ret = 0;
        if(root-&gt;val == targetSum) ret++;
        ret += rootSum(root-&gt;left, targetSum - root-&gt;val);
        ret += rootSum(root-&gt;right, targetSum - root-&gt;val);
        return ret;
    }
    int pathSum(TreeNode* root, long targetSum) {
        if(!root) return 0;
        int ret = rootSum(root, targetSum);
        ret += pathSum(root-&gt;left, targetSum);
        ret += pathSum(root-&gt;right, targetSum);
        return ret;
    }
};
</code></pre>
<h2 id="java-解法-10"><a class="header" href="#java-解法-10">Java 解法</a></h2>
<h2 id="python-解法-8"><a class="header" href="#python-解法-8">Python 解法</a></h2>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="543-diameter-of-binary-tree"><a class="header" href="#543-diameter-of-binary-tree"><a href="https://leetcode.com/problems/diameter-of-binary-tree/">543. Diameter of Binary Tree</a></a></h1>
<ul>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8D%8A%E5%BE%84.html#description">Description</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8D%8A%E5%BE%84.html#%E6%80%9D%E8%B7%AF">思路</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8D%8A%E5%BE%84.html#c-%E8%A7%A3%E6%B3%95">C++ 解法</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8D%8A%E5%BE%84.html#java-%E8%A7%A3%E6%B3%95">Java 解法</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8D%8A%E5%BE%84.html#python-%E8%A7%A3%E6%B3%95">Python 解法</a></li>
</ul>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<p>Given the <code>root</code> of a binary tree, return <em>the length of the <strong>diameter</strong> of the tree</em>.</p>
<p>The <strong>diameter</strong> of a binary tree is the <strong>length</strong> of the longest path between any two nodes in a tree. This path may or may not pass through the <code>root</code>.</p>
<p>The <strong>length</strong> of a path between two nodes is represented by the number of edges between them.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg" alt="" /></p>
<p><strong>Input:</strong> <code>root = [1,2,3,4,5]</code><br />
<strong>Output:</strong> 3<br />
<strong>Explanation:</strong> 3 is the length of the path <code>[4,2,1,3]</code> or <code>[5,2,1,3]</code>.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> <code>root = [1,2]</code><br />
<strong>Output:</strong> 1</p>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[1, 10^4]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="思路-12"><a class="header" href="#思路-12">思路</a></h2>
<p>方法一：深度优先搜索</p>
<p>首先我们知道一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。</p>
<p>而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/20240728101948.png" alt="" /></p>
<p>如图我们可以知道路径 <code>[9, 4, 2, 5, 7, 8]</code> 可以被看作以 2 为起点，从其左儿子向下遍历的路径 <code>[2, 4, 9]</code> 和从其右儿子向下遍历的路径 <code>[2, 5, 7, 8]</code> 拼接得到。</p>
<p>假设我们知道对于该节点的左儿子向下遍历经过最多的节点数 L （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 R （即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 L+R+1 。</p>
<p>我们记节点 node 为起点的路径经过节点数的最大值为 dnode，那么二叉树的直径就是所有节点 dnode的最大值减一。</p>
<p>最后的算法流程为：我们定义一个递归函数 depth(node) 计算 dnode ，函数返回该节点为根的子树的深度。先递归调用左儿子和右儿子求得它们为根的子树的深度 L 和 R ，则该节点为根的子树的深度即为max(L,R)+1</p>
<p>该节点的 dnode值为L+R+1</p>
<p>递归搜索每个节点并设一个全局变量 ans 记录 dnode的最大值，最后返回 ans-1 即为树的直径。</p>
<p>作者：力扣官方题解
链接： https://leetcode.cn/problems/diameter-of-binary-tree/solutions/139683/er-cha-shu-de-zhi-jing-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="c-解法-10"><a class="header" href="#c-解法-10">C++ 解法</a></h2>
<pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) {
        int result = INT_MIN;
        getMaxHeight(root, result);
        return result;
    }
    int getMaxHeight(TreeNode* root, int&amp; result){
        if(root == NULL){
            return 0;
        }
        int left = getMaxHeight(root-&gt;left, result);
        int right = getMaxHeight(root-&gt;right, result);
        result = max(result, left + right);
        return max(left, right) + 1;
    }
};
</code></pre>
<p>优化版本：</p>
<pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) {
        int result = INT_MIN;
        getMaxHeight(root, result);
        return result;
    }
    int getMaxHeight(TreeNode* root, int&amp; result){
        if(root == NULL){
            return 0;
        }
        if (map.count(root)) return map[root];
        int left = getMaxHeight(root-&gt;left, result);
        int right = getMaxHeight(root-&gt;right, result);
        result = max(result, left + right);
        return map[root] = max(left, right) + 1;
    }
private:
    unordered_map&lt;TreeNode*, int&gt; map;
};
</code></pre>
<h2 id="java-解法-11"><a class="header" href="#java-解法-11">Java 解法</a></h2>
<h2 id="python-解法-9"><a class="header" href="#python-解法-9">Python 解法</a></h2>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="199-binary-tree-right-side-view"><a class="header" href="#199-binary-tree-right-side-view"><a href="https://leetcode.com/problems/binary-tree-right-side-view/">199. Binary Tree Right Side View</a></a></h1>
<ul>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE.html#description">Description</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE.html#%E6%80%9D%E8%B7%AF">思路</a>
<ul>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE.html#%E6%96%B9%E6%B3%95%E4%B8%80%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">方法一：深度优先搜索</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE.html#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">方法二：广度优先搜索</a></li>
</ul>
</li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE.html#c-%E8%A7%A3%E6%B3%95">C++ 解法</a>
<ul>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE.html#dfs">dfs</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE.html#bfs">bfs</a></li>
</ul>
</li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE.html#java-%E8%A7%A3%E6%B3%95">Java 解法</a>
<ul>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE.html#dfs-1">dfs</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE.html#bfs-1">bfs</a></li>
</ul>
</li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE.html#python-%E8%A7%A3%E6%B3%95">Python 解法</a>
<ul>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE.html#dfs-2">dfs</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE.html#bfs-2">bfs</a></li>
</ul>
</li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE.html#226-invert-binary-tree">226. Invert Binary Tree</a>
<ul>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE.html#%E6%80%9D%E8%B7%AF-1">思路</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE.html#c-%E8%A7%A3%E6%B3%95-1">C++ 解法</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE.html#java-%E8%A7%A3%E6%B3%95-1">Java 解法</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE.html#python-%E8%A7%A3%E6%B3%95-1">Python 解法</a></li>
</ul>
</li>
</ul>
<h2 id="description-2"><a class="header" href="#description-2">Description</a></h2>
<p>Given the <code>root</code> of a binary tree, imagine yourself standing on the <strong>right side</strong> of it, return <em>the values of the nodes you can see ordered from top to bottom</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt="" /></p>
<p><strong>Input:</strong> <code>root = [1,2,3,null,5,null,4]</code><br />
<strong>Output:</strong> <code>[1,3,4]</code></p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> <code>root = [1,null,3]</code><br />
<strong>Output:</strong> <code>[1,3]</code></p>
<p><strong>Example 3:</strong></p>
<p><strong>Input:</strong> <code>root = []</code>
<strong>Output:</strong> <code>[]</code></p>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="思路-13"><a class="header" href="#思路-13">思路</a></h2>
<p>层次遍历，每层最后一个节点</p>
<p>由于树的形状无法提前知晓，不可能设计出优于 O(n) 的算法。因此，我们应该试着寻找线性时间解。带着这个想法，我们来考虑一些同等有效的方案。</p>
<h3 id="方法一深度优先搜索-1"><a class="header" href="#方法一深度优先搜索-1">方法一：深度优先搜索</a></h3>
<p>思路</p>
<p>我们对树进行深度优先搜索，在搜索过程中，我们总是先访问右子树。那么对于每一层来说，我们在这层见到的第一个结点一定是最右边的结点。</p>
<p>算法</p>
<p>这样一来，我们可以存储在每个深度访问的第一个结点，一旦我们知道了树的层数，就可以得到最终的结果数组。</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/199/fig1.png" alt="dfs" /></p>
<p>上图表示了问题的一个实例。红色结点自上而下组成答案，边缘以访问顺序标号。</p>
<p>复杂度分析</p>
<p>时间复杂度 : O(n)。深度优先搜索最多访问每个结点一次，因此是线性复杂度。</p>
<p>空间复杂度 : O(n)。最坏情况下，栈内会包含接近树高度的结点数量，占用 O(n) 的空间。</p>
<h3 id="方法二广度优先搜索"><a class="header" href="#方法二广度优先搜索">方法二：广度优先搜索</a></h3>
<p>思路</p>
<p>我们可以对二叉树进行层次遍历，那么对于每层来说，最右边的结点一定是最后被遍历到的。二叉树的层次遍历可以用广度优先搜索实现。</p>
<p>算法</p>
<p>执行广度优先搜索，左结点排在右结点之前，这样，我们对每一层都从左到右访问。因此，只保留每个深度最后访问的结点，我们就可以在遍历完整棵树后得到每个深度最右的结点。除了将栈改成队列，并去除了 rightmost_value_at_depth 之前的检查外，算法没有别的改动。</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/199/fig2.png" alt="bfs" /></p>
<p>上图表示了同一个示例，红色结点自上而下组成答案，边缘以访问顺序标号。</p>
<p>复杂度分析</p>
<p>时间复杂度 : O(n)。 每个节点最多进队列一次，出队列一次，因此广度优先搜索的复杂度为线性。</p>
<p>空间复杂度 : O(n)。每个节点最多进队列一次，所以队列长度最大不不超过 n，所以这里的空间代价为 O(n)。</p>
<p>作者：力扣官方题解</p>
<p>链接： https://leetcode.cn/problems/binary-tree-right-side-view/solutions/213494/er-cha-shu-de-you-shi-tu-by-leetcode-solution/</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="c-解法-11"><a class="header" href="#c-解法-11">C++ 解法</a></h2>
<h3 id="dfs"><a class="header" href="#dfs">dfs</a></h3>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) {
        unordered_map&lt;int, int&gt; rightmostValueAtDepth;
        int max_depth = -1;

        stack&lt;TreeNode*&gt; nodeStack;
        stack&lt;int&gt; depthStack;
        nodeStack.push(root);
        depthStack.push(0);

        while (!nodeStack.empty()) {
            TreeNode* node = nodeStack.top();nodeStack.pop();
            int depth = depthStack.top();depthStack.pop();

            if (node != NULL) {
            	// 维护二叉树的最大深度
                max_depth = max(max_depth, depth);

                // 如果不存在对应深度的节点我们才插入
                if (rightmostValueAtDepth.find(depth) == rightmostValueAtDepth.end()) {
                    rightmostValueAtDepth[depth] =  node -&gt; val;
                }

                nodeStack.push(node -&gt; left);
                nodeStack.push(node -&gt; right);
                depthStack.push(depth + 1);
                depthStack.push(depth + 1);
            }
        }

        vector&lt;int&gt; rightView;
        for (int depth = 0; depth &lt;= max_depth; ++depth) {
            rightView.push_back(rightmostValueAtDepth[depth]);
        }

        return rightView;
    }
};
</code></pre>
<h3 id="bfs"><a class="header" href="#bfs">bfs</a></h3>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) {
        unordered_map&lt;int, int&gt; rightmostValueAtDepth;
        int max_depth = -1;

        queue&lt;TreeNode*&gt; nodeQueue;
        queue&lt;int&gt; depthQueue;
        nodeQueue.push(root);
        depthQueue.push(0);

        while (!nodeQueue.empty()) {
            TreeNode* node = nodeQueue.front();nodeQueue.pop();
            int depth = depthQueue.front();depthQueue.pop();

            if (node != NULL) {
            	// 维护二叉树的最大深度
                max_depth = max(max_depth, depth);

                // 由于每一层最后一个访问到的节点才是我们要的答案，因此不断更新对应深度的信息即可
                rightmostValueAtDepth[depth] =  node -&gt; val;

                nodeQueue.push(node -&gt; left);
                nodeQueue.push(node -&gt; right);
                depthQueue.push(depth + 1);
                depthQueue.push(depth + 1);
            }
        }

        vector&lt;int&gt; rightView;
        for (int depth = 0; depth &lt;= max_depth; ++depth) {
            rightView.push_back(rightmostValueAtDepth[depth]);
        }

        return rightView;
    }
};
</code></pre>
<h2 id="java-解法-12"><a class="header" href="#java-解法-12">Java 解法</a></h2>
<h3 id="dfs-1"><a class="header" href="#dfs-1">dfs</a></h3>
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; rightSideView(TreeNode root) {
        Map&lt;Integer, Integer&gt; rightmostValueAtDepth = new HashMap&lt;Integer, Integer&gt;();
        int max_depth = -1;

        Deque&lt;TreeNode&gt; nodeStack = new LinkedList&lt;TreeNode&gt;();
        Deque&lt;Integer&gt; depthStack = new LinkedList&lt;Integer&gt;();
        nodeStack.push(root);
        depthStack.push(0);

        while (!nodeStack.isEmpty()) {
            TreeNode node = nodeStack.pop();
            int depth = depthStack.pop();

            if (node != null) {
            	// 维护二叉树的最大深度
                max_depth = Math.max(max_depth, depth);

                // 如果不存在对应深度的节点我们才插入
                if (!rightmostValueAtDepth.containsKey(depth)) {
                    rightmostValueAtDepth.put(depth, node.val);
                }

                nodeStack.push(node.left);
                nodeStack.push(node.right);
                depthStack.push(depth + 1);
                depthStack.push(depth + 1);
            }
        }

        List&lt;Integer&gt; rightView = new ArrayList&lt;Integer&gt;();
        for (int depth = 0; depth &lt;= max_depth; depth++) {
            rightView.add(rightmostValueAtDepth.get(depth));
        }

        return rightView;
    }
}
</code></pre>
<h3 id="bfs-1"><a class="header" href="#bfs-1">bfs</a></h3>
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; rightSideView(TreeNode root) {
        Map&lt;Integer, Integer&gt; rightmostValueAtDepth = new HashMap&lt;Integer, Integer&gt;();
        int max_depth = -1;

        Queue&lt;TreeNode&gt; nodeQueue = new LinkedList&lt;TreeNode&gt;();
        Queue&lt;Integer&gt; depthQueue = new LinkedList&lt;Integer&gt;();
        nodeQueue.add(root);
        depthQueue.add(0);

        while (!nodeQueue.isEmpty()) {
            TreeNode node = nodeQueue.remove();
            int depth = depthQueue.remove();

            if (node != null) {
            	// 维护二叉树的最大深度
                max_depth = Math.max(max_depth, depth);

                // 由于每一层最后一个访问到的节点才是我们要的答案，因此不断更新对应深度的信息即可
                rightmostValueAtDepth.put(depth, node.val);

                nodeQueue.add(node.left);
                nodeQueue.add(node.right);
                depthQueue.add(depth + 1);
                depthQueue.add(depth + 1);
            }
        }

        List&lt;Integer&gt; rightView = new ArrayList&lt;Integer&gt;();
        for (int depth = 0; depth &lt;= max_depth; depth++) {
            rightView.add(rightmostValueAtDepth.get(depth));
        }

        return rightView;
    }
}
</code></pre>
<h2 id="python-解法-10"><a class="header" href="#python-解法-10">Python 解法</a></h2>
<h3 id="dfs-2"><a class="header" href="#dfs-2">dfs</a></h3>
<pre><code class="language-python">class Solution:
    def rightSideView(self, root: TreeNode) -&gt; List[int]:
        rightmost_value_at_depth = dict() # 深度为索引，存放节点的值
        max_depth = -1

        stack = [(root, 0)]
        while stack:
            node, depth = stack.pop()

            if node is not None:
                # 维护二叉树的最大深度
                max_depth = max(max_depth, depth)

                # 如果不存在对应深度的节点我们才插入
                rightmost_value_at_depth.setdefault(depth, node.val)

                stack.append((node.left, depth + 1))
                stack.append((node.right, depth + 1))

        return [rightmost_value_at_depth[depth] for depth in range(max_depth + 1)]
</code></pre>
<h3 id="bfs-2"><a class="header" href="#bfs-2">bfs</a></h3>
<pre><code class="language-python">class Solution:
    def rightSideView(self, root: TreeNode) -&gt; List[int]:
        rightmost_value_at_depth = dict() # 深度为索引，存放节点的值
        max_depth = -1

        queue = deque([(root, 0)])
        while queue:
            node, depth = queue.popleft()

            if node is not None:
                # 维护二叉树的最大深度
                max_depth = max(max_depth, depth)

                # 由于每一层最后一个访问到的节点才是我们要的答案，因此不断更新对应深度的信息即可
                rightmost_value_at_depth[depth] = node.val

                queue.append((node.left, depth + 1))
                queue.append((node.right, depth + 1))

        return [rightmost_value_at_depth[depth] for depth in range(max_depth + 1)]
</code></pre>
<h1 id="226-invert-binary-tree"><a class="header" href="#226-invert-binary-tree"><a href="https://leetcode.com/problems/invert-binary-tree/">226. Invert Binary Tree</a></a></h1>
<p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="" /></p>
<p><strong>Input:</strong> root = [4,2,7,1,3,6,9]<br />
<strong>Output:</strong> [4,7,2,9,6,3,1]</p>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt="" /></p>
<p><strong>Input:</strong> root = [2,1,3]<br />
<strong>Output:</strong> [2,3,1]</p>
<p><strong>Example 3:</strong></p>
<p><strong>Input:</strong> root = []<br />
<strong>Output:</strong> []</p>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="思路-14"><a class="header" href="#思路-14">思路</a></h2>
<ol>
<li>
<p>先序遍历，左右交换</p>
</li>
<li>
<p>左右交换，后序遍历</p>
</li>
</ol>
<h2 id="c-解法-12"><a class="header" href="#c-解法-12">C++ 解法</a></h2>
<pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr){
            return root;
        }
        invertTree(root-&gt;left);
        invertTree(root-&gt;right);
        swap(root-&gt;left, root-&gt;right);
        return root;
    }
};
</code></pre>
<h2 id="java-解法-13"><a class="header" href="#java-解法-13">Java 解法</a></h2>
<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null){
            return null;
        }
        if(root.left == null &amp;&amp; root.right == null){
            return root;
        }
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        root.left = invertTree(root.left);
        root.right = invertTree(root.right);
        return root;
    }
}
</code></pre>
<h2 id="python-解法-11"><a class="header" href="#python-解法-11">Python 解法</a></h2>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:
        if not root:
            return
        temp = root.left
        root.left = root.right
        root.right = temp
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="回溯"><a class="header" href="#回溯">回溯</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="贪心"><a class="header" href="#贪心">贪心</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="动态规划"><a class="header" href="#动态规划">动态规划</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
